#!/bin/bash

# to generate ansible inventory file hosts.ini and ansible vars.yaml

set -euo pipefail

source "$(dirname "$0")/../cluster.env"
export SSH_PRIVATE_KEY_PATH NODES K8S_POD_CIDR K8S_SERVICE_CIDR

INVENTORY_OUTPUT_PATH="$(dirname "$0")/hosts.ini"
VARS_OUTPUT_PATH="$(dirname "$0")/vars.yaml"

echo "Generating Ansible inventory..."
echo

# Start writing hosts.ini
cat > "${INVENTORY_OUTPUT_PATH}" <<EOF
[k8s_lb]
EOF

# Extract and group nodes
for NODE in "${NODES[@]}"; do
  read -r NAME MAC IP CPU MEM DISK <<< "$NODE"

  case "$NAME" in
    k8s-lb*)
      echo "$NAME ansible_host=$IP ansible_user=ubuntu ansible_ssh_private_key_file=${SSH_PRIVATE_KEY_PATH}" >> "${INVENTORY_OUTPUT_PATH}"
      ;;
  esac
done

echo >> "${INVENTORY_OUTPUT_PATH}"
echo "[k8s_masters]" >> "${INVENTORY_OUTPUT_PATH}"
for NODE in "${NODES[@]}"; do
  read -r NAME MAC IP CPU MEM DISK <<< "$NODE"

  case "$NAME" in
    k8s-master-*)
      echo "$NAME ansible_host=$IP ansible_user=ubuntu ansible_ssh_private_key_file=${SSH_PRIVATE_KEY_PATH}" >> "${INVENTORY_OUTPUT_PATH}"
      ;;
  esac
done

echo >> "${INVENTORY_OUTPUT_PATH}"
echo "[k8s_workers]" >> "${INVENTORY_OUTPUT_PATH}"
for NODE in "${NODES[@]}"; do
  read -r NAME MAC IP CPU MEM DISK <<< "$NODE"

  case "$NAME" in
    k8s-worker-*)
      echo "$NAME ansible_host=$IP ansible_user=ubuntu ansible_ssh_private_key_file=${SSH_PRIVATE_KEY_PATH}" >> "${INVENTORY_OUTPUT_PATH}"
      ;;
  esac
done

cat >> "${INVENTORY_OUTPUT_PATH}" <<EOF

[all:vars]
ansible_python_interpreter=/usr/bin/python3
ansible_ssh_common_args='-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'
EOF

echo
echo "Ansible inventory generated: ${INVENTORY_OUTPUT_PATH}"
echo

echo "Testing connection..."
ansible -i ${INVENTORY_OUTPUT_PATH} all -m ping

echo ""
echo "Generating Ansible vars file..."

LOAD_BALANCER_IP=""
CONTROL_PLANE_NODES=()
WORKER_NODES=()
HAPROXY_VERSION="${HAPROXY_VERSION}"
CONTAINERD_VERSION="${CONTAINERD_VERSION}"
HELM_VERSION="${HELM_VERSION}"
POD_CIDR="${K8S_POD_CIDR}"
SERVICE_CIDR="${K8S_SERVICE_CIDR}"
KUBE_VERSION="${KUBE_VERSION}"
CNI_PLUGIN="${CNI_PLUGIN}"
CALICO_VERSION="${CALICO_VERSION}"
CILIUM_CLI_VERSION="${CILIUM_CLI_VERSION}"
CILIUM_VERSION="${CILIUM_VERSION}"
FLANNEL_VERSION="${FLANNEL_VERSION}"
ALLOW_SCHEDULING_ON_MASTER_NODES="${ALLOW_SCHEDULING_ON_MASTER_NODES}"
INSTALL_METRICS_SERVER="${INSTALL_METRICS_SERVER}"
METRICS_SERVER_VERSION="${METRICS_SERVER_VERSION}"
INSTALL_INGRESS_CONTROLLER="${INSTALL_INGRESS_CONTROLLER}"
INGRESS_CONTROLLER_REPLICAS="${INGRESS_CONTROLLER_REPLICAS}"
INGRESS_NGINX_VERSION="${INGRESS_NGINX_VERSION}"
TRAEFIK_HELM_CHART_VERSION="${TRAEFIK_HELM_CHART_VERSION}"
INSTALL_LONGHORN="${INSTALL_LONGHORN}"
LONGHORN_HELM_CHART_VERSION="${LONGHORN_HELM_CHART_VERSION}"
LONGHORN_VOLUME_REPLICAS="${LONGHORN_VOLUME_REPLICAS}"
LONGHORN_VOLUME_INODE_SIZE="${LONGHORN_VOLUME_INODE_SIZE}"
INSTALL_VPA="${INSTALL_VPA}"
VPA_VERSION="${VPA_VERSION}"
INSTALL_KEDA="${INSTALL_KEDA}"
KEDA_HELM_CHART_VERSION="${KEDA_HELM_CHART_VERSION}"
INSTALL_FLUX="${INSTALL_FLUX}"
FLUX_VERSION="${FLUX_VERSION}"

for NODE in "${NODES[@]}"; do
  read -r NAME MAC IP CPU MEM DISK <<< "$NODE"

  case "$NAME" in
    k8s-lb*)
      LOAD_BALANCER_IP="$IP"
      ;;
    k8s-master-*)
      CONTROL_PLANE_NODES+=("- { name: \"$NAME\", ip: \"$IP\" }")
      ;;
    k8s-worker-*)
      WORKER_NODES+=("- { name: \"$NAME\", ip: \"$IP\" }")
      ;;
  esac
done

cat > "$VARS_OUTPUT_PATH" <<EOF
# Autogenerated from cluster.env.
# DO NOT edit manually!

kube_version: "$KUBE_VERSION"

cni_plugin: "$CNI_PLUGIN"
calico_version: "$CALICO_VERSION"
cilium_cli_version: "$CILIUM_CLI_VERSION"
cilium_version: "$CILIUM_VERSION"
flannel_version: "$FLANNEL_VERSION"

pod_cidr: "$POD_CIDR"
service_cidr: "$SERVICE_CIDR"
load_balancer_ip: "$LOAD_BALANCER_IP"
kube_apiserver_port: 6443

control_plane_nodes:
$(printf '  %s\n' "${CONTROL_PLANE_NODES[@]}")

worker_nodes:
$(printf '  %s\n' "${WORKER_NODES[@]}")

allow_scheduling_on_master_nodes: $ALLOW_SCHEDULING_ON_MASTER_NODES

haproxy_version: "$HAPROXY_VERSION"
containerd_version: "$CONTAINERD_VERSION"
helm_version: "$HELM_VERSION"

install_metrics_server: $INSTALL_METRICS_SERVER
metrics_server_version: "$METRICS_SERVER_VERSION"

install_ingress_controller: "$INSTALL_INGRESS_CONTROLLER"
ingress_controller_replicas: $INGRESS_CONTROLLER_REPLICAS
ingress_nginx_version: "$INGRESS_NGINX_VERSION"
traefik_helm_chart_version: "$TRAEFIK_HELM_CHART_VERSION"

install_longhorn: $INSTALL_LONGHORN
longhorn_helm_chart_version: "$LONGHORN_HELM_CHART_VERSION"
longhorn_volume_replicas: $LONGHORN_VOLUME_REPLICAS
longhorn_volume_inode_size: $LONGHORN_VOLUME_INODE_SIZE

install_vpa: $INSTALL_VPA
vpa_version: "$VPA_VERSION"

install_keda: $INSTALL_KEDA
keda_helm_chart_version: "$KEDA_HELM_CHART_VERSION"

install_flux: $INSTALL_FLUX
flux_version: "$FLUX_VERSION"
EOF

echo "Generated Ansible vars file: ${VARS_OUTPUT_PATH}"
